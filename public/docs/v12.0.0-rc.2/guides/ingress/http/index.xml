<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>HTTP on Secure HAProxy Ingress Controller for Kubernetes</title><link>https://voyagermesh.com/docs/v12.0.0-rc.2/guides/ingress/http/</link><description>Recent content in HTTP on Secure HAProxy Ingress Controller for Kubernetes</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://voyagermesh.com/docs/v12.0.0-rc.2/guides/ingress/http/index.xml" rel="self" type="application/rss+xml"/><item><title>Blue Green Deployments | Kubernetes Ingress</title><link>https://voyagermesh.com/docs/v12.0.0-rc.2/guides/ingress/http/blue-green-deployment/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://voyagermesh.com/docs/v12.0.0-rc.2/guides/ingress/http/blue-green-deployment/</guid><description>New to Voyager? Please start here.
Blue Green Deployments Voayger supports Blue Green deployments using weighted loadbalancing for backend pods. Following example illustrates a weighted loadbalance scenario.
apiVersion: apps/v1 kind: Deployment metadata: labels: app: deployment app-version: v1 name: deployment-1 namespace: default spec: replicas: 1 selector: matchLabels: app: deployment app-version: v1 template: metadata: labels: app: deployment app-version: v1 annotations: ingress.appscode.com/backend-weight: &amp;#34;90&amp;#34; spec: containers: - env: - name: POD_NAME valueFrom: fieldRef: apiVersion: v1 fieldPath: metadata.</description></item><item><title>CORS | Kubernetes Ingress</title><link>https://voyagermesh.com/docs/v12.0.0-rc.2/guides/ingress/http/cors/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://voyagermesh.com/docs/v12.0.0-rc.2/guides/ingress/http/cors/</guid><description>New to Voyager? Please start here.
CORS Voyager can enable and configure CORS for all HTTP frontends via following ingress annotations:
ingress.appscode.com/enable-cors: If set to true enables CORS for all HTTP Frontend. By default CORS is disabled. ingress.appscode.com/cors-allow-headers: Specifies allowed headers when CORS enabled. Default value is DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization. ingress.appscode.com/cors-allow-methods: Specifies allowed methods when CORS enabled. Default value is GET,PUT,POST,DELETE,PATCH,OPTIONS. ingress.appscode.com/cors-allow-origin: Specifies allowed origins when CORS enabled. Default value is *.</description></item><item><title>Custom HTTP Port | Kubernetes Ingress</title><link>https://voyagermesh.com/docs/v12.0.0-rc.2/guides/ingress/http/custom-http-port/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://voyagermesh.com/docs/v12.0.0-rc.2/guides/ingress/http/custom-http-port/</guid><description>New to Voyager? Please start here.
Custom HTTP Port Voyager 3.2+ supports using any non-standard port (beyond 80 and 443) for L7 traffic. If no port is specified, port 80 or 443 will be used depending on whether TLS is used or not.
apiVersion: voyager.appscode.com/v1beta1 kind: Ingress metadata: name: test-ingress namespace: default spec: rules: - host: one.example.com http: port: &amp;#39;8989&amp;#39; paths: - path: /admin backend: serviceName: admin-service servicePort: &amp;#39;80&amp;#39; - path: / backend: serviceName: test-service servicePort: &amp;#39;80&amp;#39; - host: other.</description></item><item><title>Exposing Service | Kubernetes Ingress</title><link>https://voyagermesh.com/docs/v12.0.0-rc.2/guides/ingress/http/single-service/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://voyagermesh.com/docs/v12.0.0-rc.2/guides/ingress/http/single-service/</guid><description>New to Voyager? Please start here.
Exposing Service via Ingress There are existing Kubernetes concepts which allows you to expose a single service. However, you can do so through an AppsCode Ingress as well, simply by specifying a default backend with no rules.
apiVersion: voyager.appscode.com/v1beta1 kind: Ingress metadata: name: test-ingress namespace: default spec: backend: serviceName: test-service servicePort: 80 This will create a load balancer forwarding all traffic to test-service service, unconditionally.</description></item><item><title>Forward Traffic to StatefulSet Pods | Kubernetes Ingress</title><link>https://voyagermesh.com/docs/v12.0.0-rc.2/guides/ingress/http/statefulset-pod/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://voyagermesh.com/docs/v12.0.0-rc.2/guides/ingress/http/statefulset-pod/</guid><description>New to Voyager? Please start here.
Forward Traffic to StatefulSet Forward Traffic to all Pods of a StatefulSet There is the usual way of forwarding traffic to a Service matching a StatefulSet. Create a Service with the pods label selector as selector, and use the service name as Backend ServiceName.
apiVersion: apps/v1 kind: StatefulSet metadata: name: http spec: serviceName: &amp;#34;nginx-set&amp;#34; replicas: 2 template: metadata: labels: app: nginx spec: containers: - name: nginx image: gcr.</description></item><item><title>Header and URL Rewriting | Voayger</title><link>https://voyagermesh.com/docs/v12.0.0-rc.2/guides/ingress/http/rewrite-rules/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://voyagermesh.com/docs/v12.0.0-rc.2/guides/ingress/http/rewrite-rules/</guid><description>New to Voyager? Please start here.
Header and URL Rewriting AppsCode Ingress support header and URL modification at the loadbalancer level. To ensure simplicity, the header and rewrite rules follow the HAProxy syntax as it is. To add some rewrite rules for a HTTP path, follow the example below:
apiVersion: voyager.appscode.com/v1beta1 kind: Ingress metadata: name: test-ingress namespace: default spec: rules: - host: appscode.example.com http: paths: - backend: serviceName: test-service servicePort: &amp;#39;80&amp;#39; headerRules: - X-Forwarded-Host %[base] rewriteRules: - &amp;#34;^([^\\ :]*)\\ /(.</description></item><item><title>HSTS | Kubernetes Ingress</title><link>https://voyagermesh.com/docs/v12.0.0-rc.2/guides/ingress/http/hsts/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://voyagermesh.com/docs/v12.0.0-rc.2/guides/ingress/http/hsts/</guid><description>New to Voyager? Please start here.
HSTS HTTP Strict Transport Security (HSTS) is a web security policy mechanism which helps to protect websites against protocol downgrade attacks and cookie hijacking. It allows web servers to declare that web browsers (or other complying user agents) should only interact with it using secure HTTPS connections, and never via the insecure HTTP protocol. HSTS is an IETF standards track protocol and is specified in RFC 6797.</description></item><item><title>HTTP2 | Kubernetes Ingress</title><link>https://voyagermesh.com/docs/v12.0.0-rc.2/guides/ingress/http/http2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://voyagermesh.com/docs/v12.0.0-rc.2/guides/ingress/http/http2/</guid><description>New to Voyager? Please start here.
Enable HTTP/2 on ingress resource Voyager can enable HTTP/2 from version &amp;gt;=8.0.1
To enable http2, you must first setup a certificate (Let&amp;rsquo;s Encrypt), or use an existing one. Then create an ingress object like below:
apiVersion: voyager.appscode.com/v1beta1 kind: Ingress metadata: name: haproxy-ingress # name of the ingress namespace: default # namespace (optional) annotations: ingress.appscode.com/replicas: &amp;#39;2&amp;#39; # ... other annotations spec: tls: - hosts: - host.</description></item><item><title>Loadbalancer Source Range | Kubernetes Ingress</title><link>https://voyagermesh.com/docs/v12.0.0-rc.2/guides/ingress/http/source-range/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://voyagermesh.com/docs/v12.0.0-rc.2/guides/ingress/http/source-range/</guid><description>New to Voyager? Please start here.
Loadbalancer Source Range When using an Ingress with ingress.appscode.com/type: LoadBalancer annotation, you can specify the IP ranges that are allowed to access the load balancer by using spec.loadBalancerSourceRanges. This field takes a list of IP CIDR ranges, which will be forwarded to Kubernetes, that will use to configure firewall exceptions. This feature is currently supported on Google Compute Engine, Google Container Engine and AWS.</description></item><item><title>Sticky Session | Kubernetes Ingress</title><link>https://voyagermesh.com/docs/v12.0.0-rc.2/guides/ingress/http/sticky-session/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://voyagermesh.com/docs/v12.0.0-rc.2/guides/ingress/http/sticky-session/</guid><description>New to Voyager? Please start here.
Sticky Session Voyager 3.2.0+ can configure sticky connections in 2 modes. By applying annotation to an Ingress resource, you can configure all backends in that ingress to use sticky session. Or you can apply annotation to a service and configure backends using that service to use sticky session.
ingress.appscode.com/sticky-session annotations is deprecated in voyager 4.0.0+ and removed in 8.0.1+. Use ingress.appscode.com/affinity instead.</description></item><item><title>Using External Service as Ingress Backend | Kubernetes Ingress</title><link>https://voyagermesh.com/docs/v12.0.0-rc.2/guides/ingress/http/external-svc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://voyagermesh.com/docs/v12.0.0-rc.2/guides/ingress/http/external-svc/</guid><description>New to Voyager? Please start here.
Using External Service as Ingress Backend You can use an external service as a Backend for Kubernetes Ingress. There are 2 options depending on whether the external service has an external IP or DNS record.
Using External IP You can introduce any external IP address as a Kubernetes service by creating a matching Service and Endpoint object. Then you can use this service as a backend for your Ingress rules.</description></item><item><title>Virtual Hosting | Kubernetes Ingress</title><link>https://voyagermesh.com/docs/v12.0.0-rc.2/guides/ingress/http/virtual-hosting/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://voyagermesh.com/docs/v12.0.0-rc.2/guides/ingress/http/virtual-hosting/</guid><description>New to Voyager? Please start here.
Virtual Hosting Hostname based Routing Name-based virtual hosts use multiple host names for the same IP address.
foo.bar.com --| |-&amp;gt; foo.bar.com s1:80 | load balancer | bar.foo.com --| |-&amp;gt; bar.foo.com s2:80 The following Ingress tells the backing loadbalancer to route requests based on the Host header.
apiVersion: voyager.appscode.com/v1beta1 kind: Ingress metadata: name: test-ingress namespace: default spec: rules: - host: foo.bar.com http: paths: - backend: serviceName: s1 servicePort: &amp;#39;80&amp;#39; - host: bar.</description></item></channel></rss>