<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>HTTP on Secure HAProxy Ingress Controller for Kubernetes</title><link>https://voyagermesh.com/docs/5.0.0-rc.11/guides/ingress/http/</link><description>Recent content in HTTP on Secure HAProxy Ingress Controller for Kubernetes</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://voyagermesh.com/docs/5.0.0-rc.11/guides/ingress/http/index.xml" rel="self" type="application/rss+xml"/><item><title>Blue Green Deployments | Kubernetes Ingress</title><link>https://voyagermesh.com/docs/5.0.0-rc.11/guides/ingress/http/blue-green-deployment/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://voyagermesh.com/docs/5.0.0-rc.11/guides/ingress/http/blue-green-deployment/</guid><description>Blue Green Deployments Voayger supports Blue Green deployments using weighted loadbalancing for backend pods. Following example illustrates a weighted loadbalance scenario.
apiVersion: extensions/v1beta1 kind: Deployment metadata: labels: app: deployment app-version: v1 name: deployment-1 namespace: default spec: replicas: 1 selector: matchLabels: app: deployment app-version: v1 template: metadata: labels: app: deployment app-version: v1 annotations: ingress.appscode.com/backend-weight: &amp;#34;90&amp;#34; spec: containers: - env: - name: POD_NAME valueFrom: fieldRef: apiVersion: v1 fieldPath: metadata.name image: appscode/test-server:1.1 imagePullPolicy: IfNotPresent name: server ports: - containerPort: 8080 name: http-1 protocol: TCP --- apiVersion: extensions/v1beta1 kind: Deployment metadata: labels: app: deployment app-version: v2 name: deploymet-2 namespace: default spec: replicas: 1 selector: matchLabels: app: deployment app-version: v2 template: metadata: labels: app: deployment app-version: v2 annotations: ingress.</description></item><item><title>CORS | Kubernetes Ingress</title><link>https://voyagermesh.com/docs/5.0.0-rc.11/guides/ingress/http/cors/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://voyagermesh.com/docs/5.0.0-rc.11/guides/ingress/http/cors/</guid><description>CORS Applying ingress.kubenretes.io/enable-cors annotation in ingress enables CORS for all HTTP Frontend.
apiVersion: voyager.appscode.com/v1beta1 kind: Ingress metadata: name: test-ingress namespace: default annotation: ingress.kubernetes.io/enable-cors: &amp;#39;true&amp;#39; spec: rules: - host: foo.bar.com http: paths: - backend: serviceName: s1 servicePort: &amp;#39;80&amp;#39; - host: bar.foo.com http: paths: - backend: serviceName: s2 servicePort: &amp;#39;80&amp;#39; Applying the annotation in ingress will have the following effects, will add the CORS Header in the response.
$ curl -v -X 'GET' -k -H 'Origin: foo.</description></item><item><title>Custom HTTP Port | Kubernetes Ingress</title><link>https://voyagermesh.com/docs/5.0.0-rc.11/guides/ingress/http/custom-http-port/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://voyagermesh.com/docs/5.0.0-rc.11/guides/ingress/http/custom-http-port/</guid><description>Custom HTTP Port Voyager 3.2+ supports using any non-standard port (beyond 80 and 443) for L7 traffic. If no port is specified, port 80 or 443 will be used depending on whether TLS is used or not.
apiVersion: voyager.appscode.com/v1beta1 kind: Ingress metadata: name: test-ingress namespace: default spec: rules: - host: one.example.com http: port: &amp;#39;8989&amp;#39; paths: - path: /admin backend: serviceName: admin-service servicePort: &amp;#39;80&amp;#39; - path: / backend: serviceName: test-service servicePort: &amp;#39;80&amp;#39; - host: other.</description></item><item><title>Exposing Service | Kubernetes Ingress</title><link>https://voyagermesh.com/docs/5.0.0-rc.11/guides/ingress/http/single-service/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://voyagermesh.com/docs/5.0.0-rc.11/guides/ingress/http/single-service/</guid><description>Exposing Service via Ingress There are existing Kubernetes concepts which allows you to expose a single service. However, you can do so through an AppsCode Ingress as well, simply by specifying a default backend with no rules.
apiVersion: voyager.appscode.com/v1beta1 kind: Ingress metadata: name: test-ingress namespace: default spec: backend: serviceName: test-service servicePort: &amp;#39;80&amp;#39; This will create a load balancer forwarding all traffic to test-server service, unconditionally. The loadbalancer ip can be found inside Status Field of the loadbalancer described response.</description></item><item><title>Forward Traffic to StatefulSet Pods | Kubernetes Ingress</title><link>https://voyagermesh.com/docs/5.0.0-rc.11/guides/ingress/http/statefulset-pod/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://voyagermesh.com/docs/5.0.0-rc.11/guides/ingress/http/statefulset-pod/</guid><description>Forward Traffic to StatefulSet Forward Traffic to all Pods of a StatefulSet There is the usual way of forwarding traffic to a Service matching a StatefulSet. Create a Service with the pods label selector as selector, and use the service name as Backend ServiceName.
apiVersion: apps/v1beta1 kind: StatefulSet metadata: name: http spec: serviceName: &amp;#34;nginx-set&amp;#34; replicas: 2 template: metadata: labels: app: nginx spec: containers: - name: nginx image: gcr.io/google_containers/nginx-slim:0.8 ports: - containerPort: 80 name: http ---- apiVersion: v1 kind: Service metadata: name: nginx-set labels: app: nginx spec: ports: - port: 80 name: http clusterIP: None selector: app: nginx Create another service for StatefulSets pods with selector.</description></item><item><title>Header and URL Rewriting | Voayger</title><link>https://voyagermesh.com/docs/5.0.0-rc.11/guides/ingress/http/rewrite-rules/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://voyagermesh.com/docs/5.0.0-rc.11/guides/ingress/http/rewrite-rules/</guid><description>Header and URL Rewriting AppsCode Ingress support header and URL modification at the loadbalancer level. To ensure simplicity, the header and rewrite rules follow the HAProxy syntax as it is. To add some rewrite rules for a HTTP path, follow the example below:
apiVersion: voyager.appscode.com/v1beta1 kind: Ingress metadata: name: test-ingress namespace: default spec: rules: - host: appscode.example.com http: paths: - backend: serviceName: test-service servicePort: &amp;#39;80&amp;#39; headerRule: - X-Forwarded-Host %[base] rewriteRule: - &amp;#34;^([^\\ :]*)\\ /(.</description></item><item><title>HSTS | Kubernetes Ingress</title><link>https://voyagermesh.com/docs/5.0.0-rc.11/guides/ingress/http/hsts/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://voyagermesh.com/docs/5.0.0-rc.11/guides/ingress/http/hsts/</guid><description>HSTS HTTP Strict Transport Security (HSTS) is a web security policy mechanism which helps to protect websites against protocol downgrade attacks and cookie hijacking. It allows web servers to declare that web browsers (or other complying user agents) should only interact with it using secure HTTPS connections, and never via the insecure HTTP protocol. HSTS is an IETF standards track protocol and is specified in RFC 6797.
The HSTS Policy is communicated by the server to the user agent via an HTTPS response header field named &amp;ldquo;Strict-Transport-Security&amp;rdquo;.</description></item><item><title>Loadbalancer Source Range | Kubernetes Ingress</title><link>https://voyagermesh.com/docs/5.0.0-rc.11/guides/ingress/http/source-range/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://voyagermesh.com/docs/5.0.0-rc.11/guides/ingress/http/source-range/</guid><description>Loadbalancer Source Range When using an Ingress with ingress.appscode.com/type: LoadBalancer annotation, you can specify the IP ranges that are allowed to access the load balancer by using spec.loadBalancerSourceRanges. This field takes a list of IP CIDR ranges, which will be forwarded to Kubernetes, that will use to configure firewall exceptions. This feature is currently supported on Google Compute Engine, Google Container Engine and AWS. This field will be ignored if the cloud provider does not support the feature.</description></item><item><title>Sticky Session | Kubernetes Ingress</title><link>https://voyagermesh.com/docs/5.0.0-rc.11/guides/ingress/http/sticky-session/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://voyagermesh.com/docs/5.0.0-rc.11/guides/ingress/http/sticky-session/</guid><description>Sticky Session Voyager 3.2.0+ can configure sticky connections in 2 modes. By applying annotation to an Ingress resource, you can configure all backends in that ingress to use sticky session. Or you can apply annotation to a service and configure backends using that service to use sticky session.
ingress.appscode.com/sticky-session annotations is deprecated in voyager 4.0.0+. Use ingress.kubernetes.io/affinity instead.
Sticky Ingress Applying annotation ingress.kubernetes.io/affinity to Ingress will configure all backends to support sticky session.</description></item><item><title>Using External Service as Ingress Backend | Kubernetes Ingress</title><link>https://voyagermesh.com/docs/5.0.0-rc.11/guides/ingress/http/external-svc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://voyagermesh.com/docs/5.0.0-rc.11/guides/ingress/http/external-svc/</guid><description>Using External Service as Ingress Backend You can use an external service as a Backend for Kubernetes Ingress. There are 2 options depending on whether the external service has an external IP or DNS record.
Using External IP You can introduce any external IP address as a Kubernetes service by creating a matching Service and Endpoint object. Then you can use this service as a backend for your Ingress rules.</description></item><item><title>Virtual Hosting | Kubernetes Ingress</title><link>https://voyagermesh.com/docs/5.0.0-rc.11/guides/ingress/http/virtual-hosting/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://voyagermesh.com/docs/5.0.0-rc.11/guides/ingress/http/virtual-hosting/</guid><description>Virtual Hosting Hostname based Routing Name-based virtual hosts use multiple host names for the same IP address.
foo.bar.com --| |-&amp;gt; foo.bar.com s1:80 | load balancer | bar.foo.com --| |-&amp;gt; bar.foo.com s2:80 The following Ingress tells the backing loadbalancer to route requests based on the Host header.
apiVersion: voyager.appscode.com/v1beta1 kind: Ingress metadata: name: test-ingress namespace: default spec: rules: - host: foo.bar.com http: paths: - backend: serviceName: s1 servicePort: &amp;#39;80&amp;#39; - host: bar.</description></item></channel></rss>